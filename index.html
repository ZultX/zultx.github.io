<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ZultX ‚Äî v1.1</title>
<style>
:root{
  --bg:#0b0b0f;
  --panel:#0f1113;
  --muted:#9aa0a6;
  --text:#e8eaed;
  --accent:#18d018;
  --outline:#1a1a1a;
  --glass: rgba(255,255,255,0.03);
  --side-w: 320px;
  --header-bg: #ffffff;
  --header-text: #0a0a0a;
  --tip-color: #2e8b57;
  --header-h: 72px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:var(--text);background:var(--bg)}
/* ---------- HEADER (fixed, flexible) ---------- */
header{
  position:sticky;
  top:0;
  z-index:9999;
  height:var(--header-h);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:10px 14px;
  background:var(--header-bg);
  color:var(--header-text);
  border-bottom:1px solid var(--outline);
  box-shadow:0 6px 18px rgba(0,0,0,0.12);
  -webkit-tap-highlight-color: transparent;
}

/* left / center / right slots so behavior is consistent */
.header-left, .header-center, .header-right{
  display:flex;
  align-items:center;
  gap:10px;
}

/* left (hamburger + logo) */
.logo{ font-weight:900; letter-spacing:0.6px; font-size:20px; display:flex; align-items:center; gap:8px; color:var(--header-text)}
.logo .fire{ background:linear-gradient(90deg,#ff3b3b,#ff8a00); -webkit-background-clip:text; background-clip:text; color:transparent; font-weight:900 }
.logo .x-black{ background:#000; color:#fff; padding:4px 8px; border-radius:6px; font-weight:800 }

/* center (Tip / small controls) - desktop centers, mobile reflows below */
.header-center { flex: 0 0 auto; justify-content:center; min-width:0; }
.top-tip{
  display:inline-flex; align-items:center; gap:8px; padding:8px 14px;
  border-radius:999px; border:1px solid #eee; background:linear-gradient(180deg,#fff,#f7f7f7);
  box-shadow:0 6px 18px rgba(0,0,0,0.06); color:#012; cursor:pointer; user-select:none;
}
.top-tip .apple{ display:inline-flex; align-items:center; justify-content:center; padding:6px; border-radius:8px; font-weight:800; background:linear-gradient(180deg,#92e08a,#3cb371) }

/* right (letters + pill) */
.top-actions{ display:flex; gap:8px; align-items:center; margin-left:auto; }
.top-actions button{ background:var(--glass); border:1px solid var(--outline); padding:8px 12px; border-radius:8px; color:var(--text); cursor:pointer; min-height:40px }

/* ensure clickable on top - pointer events kept */
.top-tip, .top-actions button, #hamb { pointer-events:auto; z-index:10000 }

/* ---------- layout ---------- */
.app{ display:flex; height:calc(100% - var(--header-h)); }

/* side panel */
.side{
  width:var(--side-w);
  background:linear-gradient(180deg,#08090a,#0b0b0b);
  border-right:1px solid var(--outline);
  padding:12px; overflow:auto; transition:transform .28s ease; position:relative;
  z-index:10;
}
.side .menu-btn{ display:flex; align-items:center; gap:8px; padding:10px; border-radius:10px; cursor:pointer; border:1px solid transparent}
.side .menu-btn:hover{ background:rgba(255,255,255,0.02) }

/* main chat */
.main{ flex:1; display:flex; flex-direction:column; position:relative }
.center-screen{ flex:1; display:flex; align-items:center; justify-content:center; text-align:center; color:var(--muted) }
.chat-wrap{ display:flex; flex-direction:column; gap:12px; padding:18px; max-width:900px; margin:0 auto; flex:1; overflow:auto }
.msg{ padding:12px 14px; border-radius:12px; max-width:78%; white-space:pre-wrap; opacity:0; transform:translateY(6px); animation:fadeIn 240ms ease forwards }
@keyframes fadeIn{ to{ opacity:1; transform:none } }
.msg.user{ background:#071326; margin-left:auto; border-top-right-radius:2px; color:#bfe }
.msg.ai{ background:linear-gradient(180deg,#0f1720,#07101a); margin-right:auto; border-top-left-radius:2px }
.meta{ font-size:12px; color:var(--muted); margin-top:4px; display:flex; gap:8px; align-items:center }

/* typing indicator */
.typing{ display:inline-block; margin-left:6px; font-size:12px; color:var(--muted) }
.cursor{ display:inline-block; width:10px; height:18px; margin-left:6px; background:var(--text); border-radius:2px; animation:blink 1s steps(2,end) infinite }
@keyframes blink{50%{opacity:0}}

/* input bar */
.compose{ padding:12px; border-top:1px solid var(--outline); display:flex; gap:8px; align-items:center; background:linear-gradient(180deg,#020203,#0b0b0b) }
.compose textarea{ flex:1; background:transparent; border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:12px; color:var(--text); min-height:46px; resize:none }
.compose button{ background:var(--accent); border:none; padding:10px 16px; border-radius:10px; font-weight:700; cursor:pointer; color:#000 }

/* small helpers */
.hint{ color:var(--muted); font-size:13px; text-align:center; margin-top:8px }
.mode-pill{ padding:6px 8px; border-radius:999px; background:#0c0c0c; border:1px solid var(--outline); font-size:13px; color:var(--muted) }

/* responsive (mobile) */
@media (max-width:880px){
  .side{ display:none }
  .halfpanel{ width:86% }
  .center-screen .bigBtn{ width:100% }
}

/* mobile header stacking - safe, no overlap */
@media (max-width:520px){
  header{ height:auto; padding:10px; align-items:flex-start; flex-wrap:wrap }
  .header-left{ order:0; width:100%; display:flex; gap:8px; align-items:center }
  .header-center{ order:1; width:100%; justify-content:flex-start; margin:8px 0 }
  .header-right{ order:2; width:100%; display:flex; gap:8px; align-items:center; justify-content:flex-start }
  .top-tip{ padding:6px 10px; font-size:13px }
  .top-tip .apple{ padding:4px; font-size:14px }
  .top-actions button{ padding:6px 10px; font-size:13px }
}
</style>
</head>
<body>
<header>
  <div class="header-left">
    <button id="hamb" aria-label="menu" style="background:transparent;border:0;font-size:20px;cursor:pointer">‚â°</button>
    <div class="logo"><span class="fire">Zult</span><span class="x-black">X</span></div>
  </div>

  <div class="header-center">
    <div class="top-tip" id="topTipBtn" title="Tip ZultX" role="button" aria-pressed="false">
      <span class="apple">üçè</span><strong>Tip</strong>
    </div>
  </div>

  <div class="header-right top-actions">
    <button id="lettersBtn" aria-haspopup="dialog">‚úâÔ∏è Letters</button>
    <div id="modePill" class="mode-pill">Mode: Friendly</div>
  </div>
</header>

<!-- half screen panel (opens on hamburger) -->
<div id="halfPanel" class="halfpanel" role="dialog" aria-hidden="true">
  <button class="closeBtn" onclick="closeHalf()">‚úï</button>
  <h2 style="margin-top:6px">ZultX ‚Äî History & Servers</h2>
  <p style="color:var(--muted);margin-top:8px">This panel covers half the screen (desktop/tablet). It shows chat history, servers, accounts and old AI sessions.</p>
  <hr style="border-color:var(--outline)"/>
  <div id="halfContent">
    <button style="margin:8px 0;padding:10px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03)">Account</button>
    <div style="margin-top:12px;color:var(--muted)">(Demo panel ‚Äî wire up real history later)</div>
  </div>
</div>

<div class="app">
  <aside class="side" id="sidePanel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="display:flex;gap:8px;align-items:center"><strong>ZultX</strong><small style="color:var(--muted)"> v1.1</small></div>
      <div style="font-size:12px;color:var(--muted)">Hardik</div>
    </div>

    <h3>Your Chats</h3>
    <div id="historyList">
      <div class="menu-btn" onclick="newChat()">+ New chat</div>
    </div>

    <h3>Letters</h3>
    <div id="lettersList" style="display:flex;flex-direction:column;gap:6px"></div>
    <div style="height:20px"></div>
    <div class="hint">Tap messages to open. Use top Tip to support.</div>
  </aside>

  <main class="main">
    <div id="centerScreen" class="center-screen">
      <div style="max-width:720px">
        <div style="font-size:28px;font-weight:800;margin-bottom:16px;color:#fff">What can I help with?</div>
        <div style="display:flex;gap:8px;justify-content:center">
          <button class="bigBtn" onclick="focusInput()" style="padding:12px 18px;border-radius:999px;border:1px solid var(--outline);background:transparent;color:var(--text);cursor:pointer">Ask About Life With ZultX..</button>
        </div>
      </div>
    </div>

    <div id="chatArea" class="chat-wrap" style="display:none"></div>

    <div class="compose">
      <textarea id="input" placeholder="Ask ZultX Positively." rows="1"></textarea>
      <button id="sendBtn">Send</button>
    </div>
  </main>
</div>

<!-- letters modal -->
<div id="lettersModal" style="display:none;position:fixed;left:8%;top:12%;right:8%;bottom:12%;background:#061212;border-radius:12px;padding:18px;z-index:60;overflow:auto;border:1px solid #142">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <h2>Letters</h2>
    <button onclick="closeLetters()">Close</button>
  </div>
  <div id="modalLettersContent" style="white-space:pre-wrap;color:var(--text);margin-top:12px"></div>
</div>

<!-- tip modal -->
<div id="tipModal" style="display:none;position:fixed;left:18%;top:18%;right:18%;background:#061212;border-radius:12px;padding:18px;z-index:70;border:1px solid #142">
  <h3>Tip ZultX</h3>
  <div style="display:flex;gap:8px;margin-top:12px">
    <button onclick="createTip(10)">‚Çπ10</button>
    <button onclick="createTip(40)">‚Çπ40</button>
    <button onclick="createTip(100)">‚Çπ100</button>
    <button onclick="createTip(500)">‚Çπ500</button>
    <button onclick="createTip(1100)">‚Çπ1100</button>
  </div>
  <div style="margin-top:12px"><button onclick="closeTip()">Cancel</button></div>
</div>

<!-- qr modal -->
<div id="qrModal" style="display:none;position:fixed;left:18%;top:12%;right:18%;background:#061212;border-radius:12px;padding:18px;z-index:71;border:1px solid #142;text-align:center">
  <h3>Scan to pay (UPI)</h3>
  <div id="qrImgWrap" style="margin-top:12px"></div>
  <div style="margin-top:12px">
    <button id="copyUpiBtn">Copy UPI</button>
    <button onclick="closeQr()">Close</button>
  </div>
</div>

<script>
/* ---------- helpers & DOM refs ---------- */
const chatArea = document.getElementById("chatArea");
const input = document.getElementById("input");
const sendBtn = document.getElementById("sendBtn");
const centerScreen = document.getElementById("centerScreen");
const sidePanel = document.getElementById("sidePanel");
const halfPanel = document.getElementById("halfPanel");
let streaming = false;
let lastAbortController = null;

function focusInput(){
  centerScreen.style.display = "none";
  chatArea.style.display = "flex";
  input.focus();
}

/* ---------- simple UI helpers ---------- */
function newChat(){
  chatArea.innerHTML = "";
  centerScreen.style.display = "none";
  chatArea.style.display = "flex";
  addSystemMsg("New chat started.");
}
function addUserMsg(text){
  const d = document.createElement("div");
  d.className = "msg user";
  d.textContent = text;
  chatArea.appendChild(d);
  chatArea.scrollTop = chatArea.scrollHeight;
  return d;
}
function addAiMsg(text){
  const d = document.createElement("div");
  d.className = "msg ai";
  d.textContent = text || "";
  chatArea.appendChild(d);
  chatArea.scrollTop = chatArea.scrollHeight;
  return d;
}
function addSystemMsg(text){
  const d = document.createElement("div");
  d.style.textAlign = "center";
  d.style.color = "var(--muted)";
  d.style.fontSize = "13px";
  d.textContent = text;
  chatArea.appendChild(d);
  chatArea.scrollTop = chatArea.scrollHeight;
  return d;
}
function showTyping(flag){
  let t = document.getElementById("typingIndicator");
  if(flag){
    if(!t){
      t = document.createElement("div");
      t.id = "typingIndicator";
      t.className = "meta";
      t.innerHTML = 'ZultX is thinking<span class="cursor"></span>';
      chatArea.appendChild(t);
      chatArea.scrollTop = chatArea.scrollHeight;
    }
  } else {
    const el = document.getElementById("typingIndicator");
    if(el) el.remove();
  }
}
function addFeedbackRow(aiDiv, q){
  const row = document.createElement("div");
  row.className = "meta";
  row.innerHTML = `
    <button onclick="vote('up',this)">‚úÖ</button>
    <button onclick="vote('down',this)">‚ùé</button>
    <button onclick="generateShare(this)">Share</button>
  `;
  aiDiv.after(row);
}

/* ---------- robust streaming sendMessage ---------- */
async function sendMessage(){
  const text = input.value.trim();
  if(!text || streaming) return;

  // UI
  focusInput();
  addUserMsg(text);
  input.value = "";
  sendBtn.disabled = true;
  streaming = true;
  showTyping(true);
  const aiDiv = addAiMsg("");

  // Abort controller + timeout guard (prevents silent blocking)
  if(lastAbortController){
    try{ lastAbortController.abort(); }catch(_){}
  }
  const controller = new AbortController();
  lastAbortController = controller;
  const TIMEOUT_MS = 15000; // 15s to start responding
  const timeoutId = setTimeout(()=> controller.abort(), TIMEOUT_MS);

  try {
    const res = await fetch(`/ask?q=${encodeURIComponent(text)}&stream=true`, {
      headers: { "Accept": "text/event-stream, application/json, text/plain" },
      signal: controller.signal
    });

    // clear timeout if headers received
    clearTimeout(timeoutId);

    if(!res.ok){
      // try to show backend error
      let errText = await res.text().catch(()=> "Server error");
      try{ errText = JSON.parse(errText).error || JSON.parse(errText).detail || errText } catch(_){}
      aiDiv.textContent = "‚ö†Ô∏è Server error: " + errText;
      return;
    }

    // If server didn't provide a body stream (rare), read full text and show fallback
    if(!res.body){
      const full = await res.text();
      appendAiText(aiDiv, extractTextFromAny(full));
      addFeedbackRow(aiDiv, text);
      return;
    }

    // If response is SSE/text-stream, read in chunks
    const reader = res.body.getReader();
    const dec = new TextDecoder("utf-8");
    let buffer = "";

    // helper to append to ai bubble safely
    function appendChunk(t){
      if(!t) return;
      aiDiv.textContent += t;
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    // Main read loop
    while(true){
      const { value, done } = await reader.read();
      if(done) break;
      buffer += dec.decode(value, { stream: true });

      // Split into lines but allow multi-line data blocks (SSE typically 'data: {...}\n\n')
      // We'll split on double-newline to get full event blocks first
      const events = buffer.split(/\n\n/);
      buffer = events.pop(); // keep partial trailing part

      for(const ev of events){
        // each ev may contain multiple lines like "data: {...}\n" or status lines
        const lines = ev.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        let dataLines = [];
        for(const l of lines){
          if(l.startsWith("data:")){
            dataLines.push(l.slice(5).trim());
          }
        }
        if(dataLines.length === 0){
          // If no "data:" lines, treat entire block as raw text
          const raw = ev.trim();
          if(raw && raw !== "[DONE]"){
            // attempt to extract JSON or just append raw
            const maybe = extractTextFromAny(raw);
            appendChunk(maybe);
          }
          continue;
        }

        // Combine multi 'data:' lines (sometimes servers break JSON across lines)
        const payload = dataLines.join("\n");
        if(!payload || payload === "[DONE]") continue;

        // Try JSON parse payload
        let obj = null;
        try { obj = JSON.parse(payload); } catch(e){ obj = null; }

        if(obj){
          // OpenAI/Mistral style: choices[].delta.content OR choices[].message.content
          const choices = obj.choices;
          if(Array.isArray(choices)){
            for(const ch of choices){
              // delta style
              if(ch.delta && typeof ch.delta.content === "string"){
                appendChunk(ch.delta.content);
              } else if(ch.message && typeof ch.message.content === "string"){
                appendChunk(ch.message.content);
              } else if(typeof ch.text === "string"){
                appendChunk(ch.text);
              }
            }
            continue;
          }

          // Gemini-ish: candidates[0].content.parts[].text
          if(obj.candidates && obj.candidates[0] && obj.candidates[0].content && Array.isArray(obj.candidates[0].content.parts)){
            for(const p of obj.candidates[0].content.parts){
              if(p.text) appendChunk(p.text);
            }
            continue;
          }

          // Generic fallback: extract any content fields
          const text = extractTextFromAny(JSON.stringify(obj));
          appendChunk(text);
        } else {
          // Not JSON ‚Äî append raw payload
          appendChunk(payload);
        }
      } // events
    } // while

    // flush any remaining buffer (could be a final JSON without trailing blank line)
    if(buffer && buffer.trim() && buffer.trim() !== "[DONE]"){
      const remaining = buffer.trim();
      try {
        const p = JSON.parse(remaining);
        const maybe = extractTextFromAny(JSON.stringify(p));
        appendChunk(maybe);
      } catch {
        appendChunk(remaining);
      }
    }

    addFeedbackRow(aiDiv, text);

  } catch(err){
    // Abort error vs network error
    if(err.name === 'AbortError'){
      aiDiv.textContent = "‚ö†Ô∏è No response ‚Äî server taking too long. Try again.";
    } else {
      console.error(err);
      aiDiv.textContent = "‚ö†Ô∏è Connection lost.";
    }
  } finally {
    showTyping(false);
    sendBtn.disabled = false;
    streaming = false;
  }
}

/* small helper: attempt to find any human text inside messy JSON/raw */
function extractTextFromAny(s){
  if(!s) return "";
  try{
    const j = JSON.parse(s);
    // prefer common fields
    if(typeof j === 'string') return j;
    if(j.content && typeof j.content === 'string') return j.content;
    if(j.text && typeof j.text === 'string') return j.text;
    if(j.choices && j.choices[0]){
      const ch = j.choices[0];
      if(ch.text) return ch.text;
      if(ch.delta && ch.delta.content) return ch.delta.content;
      if(ch.message && ch.message.content) return ch.message.content;
    }
    // fallback: walk object to find a string value
    const fl = JSON.stringify(j).match(/"([^"]{8,})"/);
    return fl ? fl[1] : JSON.stringify(j).slice(0,500);
  }catch(e){
    return s;
  }
}

/* fallback safe append (not used primary) */
function addToAiSafe(t){
  if(!t) return;
  const last = document.querySelector(".msg.ai:last-of-type");
  if(last) last.textContent += t;
  chatArea.scrollTop = chatArea.scrollHeight;
}

/* ---------- small utilities (buttons, letters, tip, etc.) ---------- */
sendBtn.onclick = sendMessage;
input.addEventListener("keydown", e=>{
  if(e.key === "Enter" && !e.shiftKey){
    e.preventDefault();
    sendMessage();
  }
});

async function vote(kind,btn){
  const payload = {type: kind, time: Date.now()};
  try{ await fetch("/feedback", {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(payload)}); }catch(_){}
  btn.textContent = kind === 'up' ? 'Thanks üëç' : 'Sorry üòî';
}

/* share generator (unchanged) */
function generateShare(btn){
  const msg = (btn.parentNode.previousSibling && btn.parentNode.previousSibling.textContent) || "";
  const canvas = document.createElement("canvas");
  canvas.width = 1200; canvas.height = 630;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#041014"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#fff"; ctx.font = "bold 48px Inter, Arial"; ctx.fillText("ZultX", 40, 90);
  ctx.fillStyle = "#cfe"; ctx.font = "28px Inter, Arial";
  const lines = wrapText(ctx, msg, 1120);
  let y = 160;
  for(const line of lines){
    ctx.fillText(line, 40, y);
    y += 42;
    if(y > 560) break;
  }
  c
